{"code":"import { __assign, __extends, __read, __values } from \"tslib\";\r\nimport _ from 'lodash';\r\nimport minimatch from 'minimatch';\r\nimport config from './config';\r\nimport rr from './modules/rr';\r\nimport { formatLog, getCypressTestId, getCypressTestUniqueName, } from './utils/browser';\r\nimport { DEFAULT_DS_TASK_TIMEOUT, EventsHandler, NETWORK_MOCKS_CACHE_FOLDER_NAME, REQUEST_TIMEOUT, createDeploySentinelEvent, filterNonPrimitiveValues, jsonStringify, pack, performanceNow, shouldAttachDebugger, tryJSONStringify, uploadToS3, useTry, } from './utils/shared';\r\nimport { CypressRunState, LoggerSeverity, Task, } from './types';\r\nvar BrowserEventsHandler = /** @class */ (function (_super) {\r\n    __extends(BrowserEventsHandler, _super);\r\n    function BrowserEventsHandler() {\r\n        return _super !== null && _super.apply(this, arguments) || this;\r\n    }\r\n    // TODO: Memoize this\r\n    BrowserEventsHandler.prototype.getLastDomEvent = function () {\r\n        for (var i = this.events.length - 1; i >= 0; i--) {\r\n            if (this.events[i].type === 'dom') {\r\n                return this.events[i];\r\n            }\r\n        }\r\n        return null;\r\n    };\r\n    return BrowserEventsHandler;\r\n}(EventsHandler));\r\n// Global vars\r\nvar isOpenMode = Cypress.config('isInteractive');\r\nvar isComponentTest = Boolean(Cypress.config('devServer'));\r\nvar allCyTestIds = new Set();\r\nvar eventsHandler = new BrowserEventsHandler();\r\nvar filePathMap = new Map();\r\nvar logEventLookupMap = new Map();\r\nvar uploadedToS3CyTestIds = new Set();\r\nvar getFilePath = function () { return Cypress.spec.relative; };\r\nvar uploadToS3Promises = [];\r\nvar windowLocation = null;\r\n// Locally stores all mock data for this spec file\r\nvar routesByTestId = {};\r\n// This is used to access the rrweb instance after the window has loaded\r\nvar curRrweb;\r\nvar logger = {\r\n    info: function (location, message, meta) {\r\n        executeCyTask(Task.SendMessage, {\r\n            location: location,\r\n            message: message,\r\n            severity: LoggerSeverity.Info,\r\n            meta: __assign(__assign({}, meta), { isOpenMode: isOpenMode }),\r\n        });\r\n    },\r\n    warning: function (location, message, meta) {\r\n        executeCyTask(Task.SendMessage, {\r\n            location: location,\r\n            message: message,\r\n            severity: LoggerSeverity.Warning,\r\n            meta: __assign(__assign({}, meta), { isOpenMode: isOpenMode }),\r\n        });\r\n    },\r\n    error: function (location, error, meta) {\r\n        executeCyTask(Task.SendMessage, {\r\n            location: location,\r\n            message: error.message,\r\n            severity: LoggerSeverity.Error,\r\n            stack: error.stack,\r\n            meta: __assign(__assign({}, meta), { isOpenMode: isOpenMode }),\r\n        });\r\n    },\r\n};\r\n// WARNING: make sure to use this method to execute tasks\r\n// promise should always resolve or cy.wrap will stop the test\r\nvar executeCyTask = function (event, arg, options) {\r\n    return new Cypress.Promise(function (resolve) {\r\n        cy\r\n            .now('task', event, arg, __assign({ \r\n            // default options\r\n            log: false, timeout: DEFAULT_DS_TASK_TIMEOUT }, options))\r\n            .then(function (resp) { return resolve(resp); })\r\n            // theoretically, all tasks exception go to here\r\n            .catch(function (e) {\r\n            var _a;\r\n            // check if logger api throws exception, or executeCyTask goes into infinite loop\r\n            if (!((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.includes(Task.SendMessage))) {\r\n                var stringifiedArg = tryJSONStringify(arg);\r\n                logger.error('executeCyTask', e, {\r\n                    arg: stringifiedArg ? arg : 'ERROR: UNABLE TO STRINGIFY',\r\n                    event: event,\r\n                    options: options,\r\n                });\r\n            }\r\n            resolve(null);\r\n        });\r\n    });\r\n};\r\nvar awaitCyTasks = function (cyTasks, defaultTimeout) {\r\n    if (defaultTimeout === void 0) { defaultTimeout = DEFAULT_DS_TASK_TIMEOUT; }\r\n    return cy.wrap(Cypress.Promise.all(cyTasks), {\r\n        // WARNING: cy.wrap has to wait, but it shouldn't timeout whatsoever\r\n        // assuming the time between each task is less than defaultTimeout\r\n        timeout: defaultTimeout * cyTasks.length * 2,\r\n        log: false,\r\n    });\r\n};\r\nfunction getRrwebNodeIdsFromJquery($el) {\r\n    var _a;\r\n    if ($el != null &&\r\n        typeof $el.each === 'function' &&\r\n        ((_a = curRrweb === null || curRrweb === void 0 ? void 0 : curRrweb.mirror) === null || _a === void 0 ? void 0 : _a.getId) != null) {\r\n        var domElements_1 = [];\r\n        $el.each(function () {\r\n            domElements_1.push(this);\r\n        });\r\n        // -1 means the element is not serialized by RRweb (eg. it's gone or not rendered yet)\r\n        // FIXME: type curRrweb\r\n        var rrWebIds = domElements_1\r\n            .map(function (elem) { return curRrweb.mirror.getId(elem); })\r\n            .filter(function (id) { return id > -1; });\r\n        return rrWebIds;\r\n    }\r\n    return [];\r\n}\r\nvar clearLocalCacheBetweenEachTest = function () {\r\n    eventsHandler.clear();\r\n    logEventLookupMap.clear();\r\n};\r\nvar clearAllLocalCache = function () {\r\n    clearLocalCacheBetweenEachTest();\r\n    allCyTestIds.clear();\r\n    filePathMap.clear();\r\n    uploadedToS3CyTestIds.clear();\r\n};\r\nvar shouldRunGivenFilePath = function (filePath) {\r\n    if (config.SPEC) {\r\n        return config.SPEC.split(',')\r\n            .map(function (spec) { return spec.trim(); })\r\n            .some(function (spec) { return minimatch(filePath, spec); });\r\n    }\r\n    return true;\r\n};\r\nvar shouldUploadArtifacts = function (currentTest) {\r\n    // no need to upload skipped test artifacts\r\n    if (currentTest.state === CypressRunState.Pending) {\r\n        return false;\r\n    }\r\n    if (isOpenMode) {\r\n        return true;\r\n    }\r\n    return (currentTest.state === CypressRunState.Failed || config.UPLOAD_ON_PASSES);\r\n};\r\nvar stringifyAndPackBrowserArtifacts = function (events) {\r\n    var clonedBrowserEvents = null;\r\n    // 1st try\r\n    var clonedBrowserEvents1 = tryJSONStringify({ events: events });\r\n    // 2nd try\r\n    if (clonedBrowserEvents1 === null) {\r\n        logger.info('browser:jsonStringify:1st-try', 'failed to stringify events with native JSON.stringify');\r\n        var filteredEvents = events.map(function (evt) {\r\n            var singleEvent = tryJSONStringify(evt);\r\n            if (singleEvent === null) {\r\n                return __assign(__assign({}, evt), { data: filterNonPrimitiveValues(evt.data) });\r\n            }\r\n            return evt;\r\n        });\r\n        var _a = __read(jsonStringify({\r\n            events: filteredEvents,\r\n        }), 2), error2 = _a[0], clonedBrowserEvents2 = _a[1];\r\n        if (error2 !== null) {\r\n            logger.error('browser:jsonStringify:2nd-try', error2);\r\n        }\r\n        clonedBrowserEvents = clonedBrowserEvents2;\r\n    }\r\n    else {\r\n        clonedBrowserEvents = clonedBrowserEvents1;\r\n    }\r\n    if (clonedBrowserEvents) {\r\n        var _b = __read(useTry(function () {\r\n            return pack(clonedBrowserEvents);\r\n        }), 2), packError = _b[0], packResults = _b[1];\r\n        if (packError) {\r\n            logger.error('failed to pack browser artifacts', packError);\r\n        }\r\n        else if (packResults !== null) {\r\n            return packResults;\r\n        }\r\n    }\r\n    return null;\r\n};\r\nvar wrapEventHandler = function (_a) {\r\n    var event = _a.event, handler = _a.handler, log = _a.log;\r\n    try {\r\n        if (log) {\r\n            logger.info(event, \"entering browser \".concat(event, \" hook\"));\r\n        }\r\n        handler();\r\n    }\r\n    catch (e) {\r\n        console.error(e);\r\n        logger.error(event, e);\r\n    }\r\n    finally {\r\n        if (log) {\r\n            logger.info(event, \"exiting browser \".concat(event, \" hook\"));\r\n        }\r\n    }\r\n};\r\n// disable setTimeout for component tests since cy.clock overrides setTimeout\r\n// which causes debugger to timeout\r\nvar maybeSetTimeout = function (fn, ms) {\r\n    if (isComponentTest) {\r\n        fn();\r\n    }\r\n    else {\r\n        setTimeout(fn, ms);\r\n    }\r\n};\r\n// ************************************\r\n// ************ Commands **************\r\n// ************************************\r\nCypress.Commands.add('dsAddEvent', function () {\r\n    var args = [];\r\n    for (var _i = 0; _i < arguments.length; _i++) {\r\n        args[_i] = arguments[_i];\r\n    }\r\n    try {\r\n        var stringifiedMetadata = JSON.stringify(args);\r\n        // size check\r\n        if (stringifiedMetadata.length > 4 * 1e6) {\r\n            throw new Error('custom event size exceeds max limit 4 MB');\r\n        }\r\n        executeCyTask(Task.PushPluginEvent, createDeploySentinelEvent('custom', args));\r\n    }\r\n    catch (e) {\r\n        logger.error('commands:dsAddEvent', e);\r\n        // push customer-facing error\r\n        executeCyTask(Task.PushPluginEvent, createDeploySentinelEvent('custom', {}, {\r\n            message: e.message,\r\n        }));\r\n    }\r\n});\r\n// ************************************\r\n// ************ Handlers **************\r\n// ************************************\r\nvar handleTestBeforeRun = function (_) { return function () {\r\n    // WARNING: we can't fire logger.info here (unless the request is fired on the client side)\r\n    clearLocalCacheBetweenEachTest();\r\n    // WARNING: have to start CRIClient here (it gets cut off between test cases / specs)\r\n    executeCyTask(Task.StartCRI, null);\r\n}; };\r\nvar handleWindowBeforeLoad = function (win) { return function () {\r\n    injectRrweb(win);\r\n}; };\r\nvar handlerBefore = function () { return function () {\r\n    var cyTasks = [];\r\n    executeCyTask(Task.SupportFileIsDetected, null);\r\n    // Clear network mocks\r\n    cyTasks.push(executeCyTask(Task.ClearMocks, getFilePath()));\r\n    // Load network mocks\r\n    var startT = Date.now();\r\n    cyTasks.push(executeCyTask(Task.ReadMockFile, getFilePath()).then(function (data) {\r\n        var hasMocks = data !== null;\r\n        if (hasMocks) {\r\n            routesByTestId = JSON.parse(data);\r\n            executeCyTask(Task.Debug, \"[Browser] receiving all network mocks took \".concat(Date.now() - startT, \" ms\"));\r\n        }\r\n        else {\r\n            routesByTestId = {};\r\n        }\r\n    }));\r\n    awaitCyTasks(cyTasks);\r\n}; };\r\nvar handlerBeforeEach = function (currentTest) { return function () {\r\n    var e_1, _a, e_2, _b, e_3, _c;\r\n    var cyTasks = [];\r\n    var filePath = getFilePath();\r\n    var testName = getCypressTestUniqueName(currentTest);\r\n    // Try to take a snapshot just in case the test doesn't load a new page\r\n    cy.window({ log: false }).then(function (win) {\r\n        maybeSetTimeout(function () {\r\n            var _a, _b;\r\n            if ((win === null || win === void 0 ? void 0 : win.rrwebRecord) == null) {\r\n                logger.info('handlerBeforeEach', 'rrwebRecord is not defined in window');\r\n                injectRrweb(win);\r\n            }\r\n            else if (typeof ((_a = win === null || win === void 0 ? void 0 : win.rrwebRecord) === null || _a === void 0 ? void 0 : _a.takeFullSnapshot) !== 'function') {\r\n                logger.info('handlerBeforeEach', 'rrwebRecord takeFullSnapshot is not a function');\r\n            }\r\n            (_b = win === null || win === void 0 ? void 0 : win.rrwebRecord) === null || _b === void 0 ? void 0 : _b.takeFullSnapshot();\r\n        }, 0);\r\n    });\r\n    // intercept networks\r\n    if (testName in routesByTestId) {\r\n        var sortedRoutes_1 = {};\r\n        try {\r\n            for (var _d = __values(routesByTestId[testName]), _e = _d.next(); !_e.done; _e = _d.next()) {\r\n                var request = _e.value;\r\n                if (!sortedRoutes_1[request.method]) {\r\n                    sortedRoutes_1[request.method] = {};\r\n                }\r\n                if (!sortedRoutes_1[request.method][request.url]) {\r\n                    sortedRoutes_1[request.method][request.url] = {\r\n                        index: 0,\r\n                        responses: [],\r\n                    };\r\n                }\r\n                sortedRoutes_1[request.method][request.url].responses.push(request);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n        var createStubbedRoute = function (method, url) {\r\n            var _a = sortedRoutes_1[method][url], responses = _a.responses, index = _a.index;\r\n            cy.intercept({\r\n                url: url,\r\n                method: method,\r\n            }, function (req) {\r\n                var mockResponse = responses[index];\r\n                req.reply({\r\n                    fixture: \"\".concat(NETWORK_MOCKS_CACHE_FOLDER_NAME, \"/\").concat(mockResponse.cacheLookupKey, \".json\"),\r\n                    statusCode: mockResponse.status,\r\n                });\r\n                if (sortedRoutes_1[method][url].responses.length > index + 1) {\r\n                    sortedRoutes_1[method][url].index += 1;\r\n                }\r\n            });\r\n        };\r\n        // Stub all recorded routes\r\n        var startT = Date.now();\r\n        try {\r\n            for (var _f = __values(Object.keys(sortedRoutes_1)), _g = _f.next(); !_g.done; _g = _f.next()) {\r\n                var method = _g.value;\r\n                try {\r\n                    for (var _h = (e_3 = void 0, __values(Object.keys(sortedRoutes_1[method]))), _j = _h.next(); !_j.done; _j = _h.next()) {\r\n                        var url = _j.value;\r\n                        createStubbedRoute(method, url);\r\n                    }\r\n                }\r\n                catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                finally {\r\n                    try {\r\n                        if (_j && !_j.done && (_c = _h.return)) _c.call(_h);\r\n                    }\r\n                    finally { if (e_3) throw e_3.error; }\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        executeCyTask(Task.Debug, \"[Browser] intercepting networks took \".concat(Date.now() - startT, \" ms for test \\\"\").concat(testName, \"\\\"\"));\r\n    }\r\n    if (currentTest.type === 'test') {\r\n        if (shouldRunGivenFilePath(filePath)) {\r\n            var cyTestId_1 = getCypressTestId(filePath, currentTest);\r\n            var suiteTitles = [];\r\n            var testName_1 = getCypressTestUniqueName(currentTest, suiteTitles);\r\n            cyTasks.push(executeCyTask(Task.CreateRun, {\r\n                cyTestId: cyTestId_1,\r\n                runPayload: {\r\n                    // invocationDetails doesn't exist for retries\r\n                    testName: filePath,\r\n                    code: currentTest.body,\r\n                    retryNumber: currentTest.currentRetry(),\r\n                    retries: currentTest._retries,\r\n                    name: testName_1,\r\n                    suiteTitles: suiteTitles,\r\n                    startedAt: currentTest.wallClockStartedAt,\r\n                    clientId: currentTest.id,\r\n                },\r\n            }).then(function () {\r\n                allCyTestIds.add(cyTestId_1);\r\n            }));\r\n        }\r\n    }\r\n    awaitCyTasks(cyTasks);\r\n}; };\r\nvar handleAfterEach = function (currentTest) { return function () {\r\n    var _a, _b;\r\n    var cyTasks = [];\r\n    var filePath = getFilePath();\r\n    var cyTestId = getCypressTestId(filePath, currentTest);\r\n    if (currentTest.type === 'test' && allCyTestIds.has(cyTestId)) {\r\n        var testName = getCypressTestUniqueName(currentTest);\r\n        cyTasks.push(executeCyTask(Task.RecordMocks, testName));\r\n        if (shouldUploadArtifacts(currentTest) &&\r\n            !uploadedToS3CyTestIds.has(cyTestId)) {\r\n            uploadedToS3CyTestIds.add(cyTestId);\r\n            // push an internal 'End of Test' log event\r\n            eventsHandler.push(createDeploySentinelEvent('log', {\r\n                beforeDomEventId: (_a = eventsHandler.getLastDomEvent()) === null || _a === void 0 ? void 0 : _a.id,\r\n                afterDomEventId: (_b = eventsHandler.getLastDomEvent()) === null || _b === void 0 ? void 0 : _b.id,\r\n                name: 'End of Test',\r\n                message: '',\r\n            }));\r\n            var artifacts_1 = stringifyAndPackBrowserArtifacts(eventsHandler.get());\r\n            if (artifacts_1) {\r\n                // upload browser artifacts\r\n                // TODO: move this to after:run so debugger can catch other 'after' hook events\r\n                cyTasks.push(executeCyTask(Task.GetBrowserArtifactsPresignedUrl, cyTestId).then(function (presignedUrl) {\r\n                    if (presignedUrl) {\r\n                        // WARNING: resolve this in 'after' hook\r\n                        uploadToS3Promises.push(new Cypress.Promise(function (resolve) {\r\n                            // TODO: we can possibly remove this setTimeout since artifacts is stringified already\r\n                            maybeSetTimeout(function () {\r\n                                uploadToS3({\r\n                                    url: presignedUrl,\r\n                                    artifacts: artifacts_1,\r\n                                    notifier: logger.error,\r\n                                }).finally(function () { return resolve(); });\r\n                            }, 0);\r\n                        }));\r\n                    }\r\n                    else {\r\n                        logger.warning('handleAfterEach', 'received nullish presignedUrl');\r\n                    }\r\n                }));\r\n            }\r\n            else {\r\n                logger.error('handleAfterEach', new Error('failed to stringify and pack browser artifacts'));\r\n            }\r\n        }\r\n    }\r\n    awaitCyTasks(cyTasks);\r\n}; };\r\nvar handleAfter = function () { return function () {\r\n    awaitCyTasks(uploadToS3Promises, REQUEST_TIMEOUT);\r\n}; };\r\nvar handleTestAfterRun = function (currentTest) { return function () {\r\n    var filePath = getFilePath();\r\n    var cyTestId = getCypressTestId(filePath, currentTest);\r\n    if (currentTest.type === 'test') {\r\n        executeCyTask(Task.WriteMocksToFile, filePath);\r\n        executeCyTask(Task.StopCRI, null);\r\n        var logRunUrlAndUploadPluginArtifacts_1 = function () {\r\n            if (shouldUploadArtifacts(currentTest)) {\r\n                executeCyTask(Task.LogRunUrl, cyTestId);\r\n                // upload plugin artifacts\r\n                executeCyTask(Task.UploadArtifacts, cyTestId);\r\n            }\r\n        };\r\n        var clearLocalCache_1 = function () {\r\n            if (isOpenMode) {\r\n                clearAllLocalCache();\r\n                executeCyTask(Task.ClearTestLocalCache, cyTestId);\r\n            }\r\n        };\r\n        if (allCyTestIds.has(cyTestId)) {\r\n            executeCyTask(Task.CompleteRun, {\r\n                cyTestId: cyTestId,\r\n                runPayload: {\r\n                    completedAt: new Date(),\r\n                    took: currentTest.wallClockDuration,\r\n                    state: currentTest.state,\r\n                    errorTrace: currentTest.err\r\n                        ? {\r\n                            message: currentTest.err.message,\r\n                            name: currentTest.err.name,\r\n                            codeFrame: currentTest.err.codeFrame,\r\n                            stack: currentTest.err.stack,\r\n                            sourceMappedStack: currentTest.err.sourceMappedStack,\r\n                        }\r\n                        : {},\r\n                },\r\n            });\r\n            logRunUrlAndUploadPluginArtifacts_1();\r\n            clearLocalCache_1();\r\n        }\r\n        else {\r\n            var suiteTitles = [];\r\n            var testName = getCypressTestUniqueName(currentTest, suiteTitles);\r\n            // test might crash within 'before' hook\r\n            executeCyTask(Task.CreateRun, {\r\n                cyTestId: cyTestId,\r\n                runPayload: {\r\n                    // invocationDetails doesn't exist for retries\r\n                    testName: filePath,\r\n                    code: currentTest.body,\r\n                    retryNumber: currentTest.currentRetry(),\r\n                    took: currentTest.wallClockDuration,\r\n                    retries: currentTest._retries,\r\n                    name: testName,\r\n                    suiteTitles: suiteTitles,\r\n                    startedAt: currentTest.wallClockStartedAt,\r\n                    completedAt: new Date(),\r\n                    clientId: currentTest.id,\r\n                    state: currentTest.state,\r\n                    errorTrace: currentTest.err\r\n                        ? {\r\n                            message: currentTest.err.message,\r\n                            name: currentTest.err.name,\r\n                            codeFrame: currentTest.err.codeFrame,\r\n                            stack: currentTest.err.stack,\r\n                            sourceMappedStack: currentTest.err.sourceMappedStack,\r\n                        }\r\n                        : {},\r\n                },\r\n            }).then(function () {\r\n                allCyTestIds.add(cyTestId);\r\n                // execute tasks here to make sure the createRun promise is initialized\r\n                logRunUrlAndUploadPluginArtifacts_1();\r\n                clearLocalCache_1();\r\n            });\r\n        }\r\n    }\r\n}; };\r\nvar injectRrweb = function (win) {\r\n    var _a, _b;\r\n    if (win.rrwebRecord) {\r\n        logger.info('injectRrweb', 'injectRrweb called when rrweb already exists on window');\r\n        return;\r\n    }\r\n    var script = win.document.createElement('script');\r\n    script.innerHTML = rr;\r\n    script.type = 'text/javascript';\r\n    win.document.head.appendChild(script);\r\n    curRrweb = win.rrwebRecord;\r\n    // FIXME: type rrwebRecord so its callable\r\n    (_b = (_a = win).rrwebRecord) === null || _b === void 0 ? void 0 : _b.call(_a, {\r\n        emit: function (event) {\r\n            var dsEvent = createDeploySentinelEvent('dom', event);\r\n            eventsHandler.push(dsEvent);\r\n        },\r\n    });\r\n};\r\nvar handleLogAdded = function (log) { return function () {\r\n    var _a, _b, _c, _d;\r\n    // from 'fail' and 'uncaught:exception'\r\n    if (((_b = (_a = log.err) === null || _a === void 0 ? void 0 : _a.message) === null || _b === void 0 ? void 0 : _b.includes('DeploySentinelTask')) ||\r\n        ((_c = log.message) === null || _c === void 0 ? void 0 : _c.includes('DeploySentinelTask'))) {\r\n        return;\r\n    }\r\n    // Need to wrap in \"attributes\" to match command.logs format\r\n    var beforeDomRrwebNodeIds = null;\r\n    wrapEventHandler({\r\n        event: 'log:added:highlightDom',\r\n        log: false,\r\n        handler: function () {\r\n            beforeDomRrwebNodeIds = getRrwebNodeIdsFromJquery(log.$el);\r\n        },\r\n    });\r\n    var dsEvent = createDeploySentinelEvent('log', __assign({ beforeDomEventId: (_d = eventsHandler.getLastDomEvent()) === null || _d === void 0 ? void 0 : _d.id, beforeDomRrwebNodeIds: beforeDomRrwebNodeIds, windowLocation: windowLocation }, formatLog(log)));\r\n    logEventLookupMap.set(log.id, dsEvent);\r\n    eventsHandler.push(dsEvent);\r\n    executeCyTask(Task.PushPluginEvent, {\r\n        type: dsEvent.type,\r\n        id: dsEvent.id,\r\n        data: {\r\n            name: dsEvent.data.name,\r\n        },\r\n        offset: dsEvent.offset,\r\n        ts: dsEvent.ts,\r\n    });\r\n}; };\r\nvar handleOnHookStarts = function (hook) { return function () {\r\n    var dsEvent = createDeploySentinelEvent('hook', {\r\n        // body: hook.body,\r\n        // duration: hook.duration,\r\n        // file: hook.file,\r\n        hookName: hook.hookName,\r\n        hookId: hook.hookId,\r\n        // errorTrace: hook.err\r\n        //   ? {\r\n        //       message: hook.err.message,\r\n        //       name: hook.err.name,\r\n        //       codeFrame: hook.err.codeFrame,\r\n        //       stack: hook.err.stack,\r\n        //       sourceMappedStack: hook.err.sourceMappedStack,\r\n        //     }\r\n        //   : {},\r\n    });\r\n    eventsHandler.push(dsEvent);\r\n}; };\r\nvar handleLogChanged = function (log) { return function () {\r\n    var _a;\r\n    var logEvent = logEventLookupMap.get(log.id);\r\n    if (logEvent !== undefined) {\r\n        var afterDomEventId = (_a = eventsHandler.getLastDomEvent()) === null || _a === void 0 ? void 0 : _a.id;\r\n        var afterDomRrwebNodeIds_1 = null;\r\n        wrapEventHandler({\r\n            event: 'log:changed:highlightDom',\r\n            log: false,\r\n            handler: function () {\r\n                afterDomRrwebNodeIds_1 = getRrwebNodeIdsFromJquery(log.$el);\r\n            },\r\n        });\r\n        logEvent.took = Math.round(performanceNow() - logEvent.offset);\r\n        logEvent.data = __assign({ beforeDomEventId: logEvent.data.beforeDomEventId, beforeDomRrwebNodeIds: logEvent.data.beforeDomRrwebNodeIds, afterDomEventId: afterDomEventId, afterDomRrwebNodeIds: afterDomRrwebNodeIds_1, windowLocation: logEvent.data.windowLocation }, formatLog(log));\r\n        eventsHandler.update(logEvent);\r\n    }\r\n}; };\r\nif (shouldAttachDebugger(config.DS_API_KEY)) {\r\n    Cypress.on('test:before:run:async', function (_, currentTest) {\r\n        wrapEventHandler({\r\n            event: 'test:before:run:async',\r\n            log: true,\r\n            handler: handleTestBeforeRun(currentTest),\r\n        });\r\n    });\r\n    Cypress.on('window:before:load', function (win) {\r\n        wrapEventHandler({\r\n            event: 'window:before:load',\r\n            log: true,\r\n            handler: handleWindowBeforeLoad(win),\r\n        });\r\n    });\r\n    before(function () {\r\n        wrapEventHandler({\r\n            event: 'before',\r\n            log: true,\r\n            handler: handlerBefore(),\r\n        });\r\n    });\r\n    beforeEach(function () {\r\n        wrapEventHandler({\r\n            event: 'beforeEach',\r\n            log: true,\r\n            handler: handlerBeforeEach(this.currentTest),\r\n        });\r\n    });\r\n    Cypress.on('url:changed', function (url) {\r\n        windowLocation = url;\r\n    });\r\n    Cypress.on('log:added', function (log) {\r\n        wrapEventHandler({\r\n            event: 'log:added',\r\n            log: false,\r\n            handler: handleLogAdded(log),\r\n        });\r\n    });\r\n    Cypress.on('log:changed', function (log) {\r\n        wrapEventHandler({\r\n            event: 'log:changed',\r\n            log: false,\r\n            handler: handleLogChanged(log),\r\n        });\r\n    });\r\n    afterEach(function () {\r\n        wrapEventHandler({\r\n            event: 'afterEach',\r\n            log: true,\r\n            handler: handleAfterEach(this.currentTest),\r\n        });\r\n    });\r\n    after(function () {\r\n        wrapEventHandler({\r\n            event: 'after',\r\n            log: true,\r\n            handler: handleAfter(),\r\n        });\r\n    });\r\n    Cypress.on('test:after:run', function (_attrs, currentTest) {\r\n        wrapEventHandler({\r\n            event: 'test:after:run',\r\n            log: true,\r\n            handler: handleTestAfterRun(currentTest),\r\n        });\r\n    });\r\n    Cypress.on('uncaught:exception', function (e, _runnable) {\r\n        // silence exceptions thrown by DeploySentinel tasks\r\n        if (_.some(Object.values(Task), function (task) { return e.message.includes(task); })) {\r\n            if (!e.message.includes(Task.SendMessage)) {\r\n                logger.error('uncaught:exceptions', e);\r\n            }\r\n            return false;\r\n        }\r\n    });\r\n    // TODO -> decide if we need to track hook events (need to exclude debugger events)\r\n    var mochaRunner = Cypress.mocha.getRunner();\r\n    mochaRunner.on('hook', function (hook) {\r\n        wrapEventHandler({\r\n            event: 'mocha:hook',\r\n            log: false,\r\n            handler: handleOnHookStarts(hook),\r\n        });\r\n    });\r\n}\r\n","references":["/home/warren/Codes/deploysentinel/debugger/node_modules/cypress/types/bluebird/index.d.ts","/home/warren/Codes/deploysentinel/debugger/node_modules/@types/lodash/index.d.ts","/home/warren/Codes/deploysentinel/debugger/node_modules/@types/minimatch/index.d.ts","/home/warren/Codes/deploysentinel/debugger/packages/cypress/src/config.ts","/home/warren/Codes/deploysentinel/debugger/packages/cypress/src/modules/rr.ts","/home/warren/Codes/deploysentinel/debugger/packages/cypress/src/utils/browser.ts","/home/warren/Codes/deploysentinel/debugger/packages/cypress/src/utils/shared.ts","/home/warren/Codes/deploysentinel/debugger/packages/cypress/src/types.ts"],"dts":{"name":"/home/warren/Codes/deploysentinel/debugger/packages/cypress/node_modules/.cache/rollup-plugin-typescript2/placeholder/src/support.d.ts","writeByteOrderMark":false,"text":"export {};\r\n"}}
