/// <reference types="cypress" />
/// <reference types="cypress" />
import type { Protocol } from 'devtools-protocol/types/protocol';
export type RuntimeMetrics = {
    os: {
        freemem: number;
        totalmem: number;
    };
    nodeProcess: {
        totalHeapSize: number;
        usedHeapSize: number;
    };
    browser: {
        jsHeapUsedSize?: number;
        jsHeapTotalSize?: number;
    };
};
export type NetworkMocksFilter = {
    includeUrls: string[];
    excludeUrls: string[];
};
export type APIClientConfig = {
    apiKey: string;
    baseUrl: string;
    buildId: string | undefined;
    getRuntimeMetrics: () => Promise<RuntimeMetrics> | null;
    verbose?: boolean;
};
export type TestConfig = {
    cypressVersion: string;
    defaultCommandTimeout: number | undefined;
    group?: string;
    pageLoadTimeout: number | undefined;
    parallel: boolean | undefined;
    projectId: string | null;
    reporter: string | undefined;
    reporterOptions: unknown;
    requestTimeout: number | undefined;
    resolvedNodeVersion: string | undefined;
    responseTimeout: number | undefined;
    tag?: string;
    taskTimeout: number | undefined;
    video: boolean | undefined;
    videoUploadOnPasses: boolean | undefined;
    browser: {
        isHeadless: boolean | undefined;
        name: string | undefined;
        version: string | undefined;
    };
    system: {
        osName: string;
        osVersion: string;
    };
};
export type LoggerMessage = {
    message: string | Error;
    location: string;
    meta?: {
        [key: string]: unknown;
    };
};
export declare enum LoggerSeverity {
    Error = "error",
    Info = "info",
    Warning = "warning"
}
export type DeploySentienlEventType = 'browserLogEntry' | 'console' | 'custom' | 'dom' | 'exception' | 'hook' | 'log' | 'network';
export type DSEventError = {
    message: string;
};
type DSNetworkRequestEventPayload = {
    referrerPolicy: string;
    id: string;
    timestamp: number;
    url: string;
    headers: {
        [key: string]: string;
    };
    method: string;
    type: 'Document' | 'Stylesheet' | 'Image' | 'Media' | 'Font' | 'Script' | 'TextTrack' | 'XHR' | 'Fetch' | 'EventSource' | 'WebSocket' | 'Manifest' | 'SignedExchange' | 'Ping' | 'CSPViolationReport' | 'Preflight' | 'Other';
};
type DSNetworkResponseEventPayload = {
    connectionReused: boolean;
    encodedDataLength: number;
    fromDiskCache: boolean;
    fromPrefetchCache: boolean;
    fromServiceWorker: boolean;
    headers: {
        [key: string]: string;
    };
    mimeType: string;
    protocol: string;
    remoteIPAddress: string;
    remotePort: number;
    statusCode: number;
    statusMessage: string;
    timestamp: number;
    timing: {
        requestTime: number;
        proxyStart: number;
        proxyEnd: number;
        dnsStart: number;
        dnsEnd: number;
        connectStart: number;
        connectEnd: number;
        sslStart: number;
        sslEnd: number;
        workerStart: number;
        workerReady: number;
        workerFetchStart: number;
        workerRespondWithSettled: number;
        sendStart: number;
        sendEnd: number;
        pushStart: number;
        pushEnd: number;
        receiveHeadersEnd: number;
    };
    type: string;
    bodySize: number;
    base64Encoded: boolean;
    body: string;
};
type DSNetworkEventPayload = {
    type: 'network';
    data: {
        requestServedFromCache: boolean;
        loadingFailed?: {
            canceled: boolean;
            errorText: string;
            timestamp: number;
            type: string;
        };
        req: DSNetworkRequestEventPayload;
        res?: DSNetworkResponseEventPayload;
    };
    id: string;
    offset: number;
    took?: number;
    ts: number;
};
export type DSEvent = {
    data: any;
    id: string;
    offset: number;
    took?: number;
    ts: number;
    type: Exclude<Exclude<DeploySentienlEventType, 'network'>, 'log'>;
} | {
    type: 'log';
    id: string;
    offset: number;
    took?: number;
    ts: number;
    data: {
        beforeDomEventId: string;
        beforeDomRrwebNodeIds: number[];
        afterDomEventId: string;
        afterDomRrwebNodeIds: number[];
        windowLocation: string;
        id: string;
        chainerId: string;
        err?: {
            message: string;
            name: string;
            stack: string;
            parsedStack: any[];
        };
        type: 'parent' | string;
        displayName?: 'fetch' | string;
        hookId?: string;
        wallClockStartedAt: string;
        renderProps: any;
        consoleProps: any;
        url: string;
        name: string;
        message: string;
        event: boolean;
        ended: boolean;
        state: 'failed' | string;
    };
} | DSNetworkEventPayload;
export type DSRun = {
    _id: string;
    s3PresignedUrls: {
        backendLogs: string | null;
        browser: string | null;
        internal: string | null;
        plugin: string | null;
        screenshot: string | null;
    };
};
export type DSNetworkMockEvent = {
    body: unknown;
    cacheLookupKey?: string;
    method: string;
    response: unknown;
    status: number;
    type: string;
    url: string;
};
export type RunsMapValue = {
    backendLogsPresignedUrl: string | null;
    completedAt?: number;
    retryNumber: number;
    spec: string;
    startedAt: number;
    suiteTitles: string[];
};
export type RunPayload = {
    ciProvider: string | null;
    code: string;
    commitInfo?: CommitInfo;
    name: string;
    retries: number;
    retryNumber: number;
    startedAt: Date;
    testName: string;
};
export type PatchRunPayload = {
    batchId: string;
    ciProvider?: string;
    completedAt: Date;
    took: number;
    state: string;
    errorTrace?: {
        message: string;
        name: string;
        codeFrame: string;
        stack: string;
        sourceMappedStack: string;
    };
    networkTimings?: {
        [url: string]: number[];
    } | null;
};
export type DSNetworkEvent = {
    /** @deprecated use request.url instead */
    url?: string;
    /** @deprecated use request.method instead */
    method?: string;
    /** @deprecated use request.headers instead */
    headers?: {
        [key: string]: string;
    };
    request: {
        url: string;
        method: string;
        headers: {
            [key: string]: string;
        };
    };
    response?: {
        headers: {
            [key: string]: string;
        };
        statusCode: number;
        statusMessage: string;
        bodySize: number;
        body: string;
    };
};
export declare enum NetworkMockMode {
    Record = "record",
    Intercept = "intercept"
}
export type DebuggerOptions = {
    networkMock?: {
        clearMocks?: boolean;
        excludeUrls?: string[];
        includeUrls?: string[];
        methods?: ('GET' | 'POST' | 'PATCH' | 'PUT' | 'DELETE' | 'HEAD')[];
        mode: NetworkMockMode;
        resourceTypes?: Protocol.Network.ResourceType[];
    };
    beforeNetworkSend?: (event: DSNetworkEvent) => DSNetworkEvent | null | undefined;
};
export declare enum CypressRunState {
    Failed = "failed",
    Passed = "passed",
    Pending = "pending",
    Skipped = "skipped"
}
export type CypressError = {
    message: string;
    name: string;
    codeFrame: {
        absoluteFile: string;
        column: number;
        frame: string;
        language: string;
        line: number;
        originalFile: string;
        relativeFile: string;
    };
    stack: string;
    sourceMappedStack: string;
};
export type CommandLog = {
    alias?: string;
    id: string;
    name: string;
    message: string;
    event: boolean;
    ended: boolean;
    state: 'passed' | 'failed' | 'pending';
    chainerId: string;
    wallClockStartedAt: Date;
    type: string;
    err?: CypressError;
    $el?: JQuery<HTMLElement>;
    renderProps: {
        indicator?: string;
        message?: string;
    };
    numElements?: number;
    highlightAttr?: string;
    hookId: string;
    displayName: string;
    method: 'GET' | 'POST';
    consoleProps: {
        Command: string;
        Elements?: number;
        Error?: string;
        Method?: string;
        Selector?: string;
        URL?: string;
        Yielded?: unknown;
        Request?: {
            'Request Body'?: unknown;
            'Request Headers': Record<string, string>;
            'Request URL': string;
            'Response Body'?: string;
            'Response Headers'?: Record<string, string>;
            'Response Status'?: number;
        };
    };
    url: string;
    passed?: boolean;
    actual?: boolean;
    expected?: boolean;
};
export type CypressTest = {
    id: string;
    type: 'test';
    body: string;
    _retries: number;
    _currentRetry: number;
    title: string;
    wallClockStartedAt: Date;
    wallClockDuration: number;
    state: CypressRunState;
    err?: CypressError;
    invocationDetails?: {
        relativeFile: string;
    };
    parent: CypressSuite;
};
export type CypressSuite = {
    id: string;
    title: string;
    type: 'suite';
    parent: CypressSuite;
};
export type CommitInfo = {
    authorEmail: string | null;
    authorName: string | null;
    branch: string | null;
    ciBuildId: string | null;
    defaultBranch: string | null;
    message: string | null;
    remoteBranch: string | null;
    remoteOrigin: string | null;
    sha: string | null;
    timestamp: number | null;
    metadata: unknown | null;
};
export declare enum Task {
    ClearMocks = "DeploySentinelTaskClearMocks",
    ClearTestLocalCache = "DeploySentinelTaskClearTestLocalCache",
    CompleteRun = "DeploySentinelTaskCompleteRun",
    CreateRun = "DeploySentinelTaskCreateRun",
    Debug = "DeploySentinelTaskDebug",
    GetBrowserArtifactsPresignedUrl = "DeploySentinelTaskGetBrowserArtifactsPresignedUrl",
    LogRunUrl = "DeploySentinelTaskLogRunUrl",
    PushPluginEvent = "DeploySentinelTaskPushPluginEvent",
    ReadMockFile = "DeploySentinelTaskReadMockFile",
    RecordMocks = "DeploySentinelTaskRecordMocks",
    SendMessage = "DeploySentinelTaskSendMessage",
    StartCRI = "DeploySentinelTaskStartCRI",
    StopCRI = "DeploySentinelTaskStopCRI",
    SupportFileIsDetected = "DeploySentinelTaskSupportFileIsDetected",
    UploadBrowserArtifacts = "DeploySentinelTaskUploadBrowserArtifacts",
    UploadPluginArtifacts = "DeploySentinelTaskUploadPluginArtifacts",
    WriteMocksToFile = "DeploySentinelTaskWriteMocksToFile"
}
export type JunitReporterOptions = {
    jenkinsMode?: boolean;
    mochaFile?: string;
    suiteTitleSeparatedBy?: string;
    testCaseSwitchClassnameAndName?: boolean;
};
export {};
