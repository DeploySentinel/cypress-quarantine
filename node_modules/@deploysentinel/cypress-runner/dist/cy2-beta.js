"use strict";
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _extends() {
    _extends = Object.assign || function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    };
    return _extends.apply(this, arguments);
}
var x = Object.create;
var F = Object.defineProperty;
var X = Object.getOwnPropertyDescriptor;
var G = Object.getOwnPropertyNames;
var z = Object.getPrototypeOf, H = Object.prototype.hasOwnProperty;
var O = (V, t)=>{
    for(var R in t)F(V, R, {
        get: t[R],
        enumerable: !0
    });
}, m = (V, t, R, U)=>{
    if (t && typeof t == 'object' || typeof t == 'function') for (let d of G(t))!H.call(V, d) && d !== R && F(V, d, {
        get: ()=>t[d],
        enumerable: !(U = X(t, d)) || U.enumerable
    });
    return V;
};
var p = (V, t, R)=>(R = V != null ? x(z(V)) : {}, m(t || !V || !V.__esModule ? F(R, 'default', {
        value: V,
        enumerable: !0
    }) : R, V)), C = (V)=>m(F({}, '__esModule', {
        value: !0
    }), V);
var g = {};
O(g, {
    getCypressCLIBinPath: ()=>l,
    run: ()=>w,
    spawn: ()=>B
});
module.exports = C(g);
var NV = require('source-map-support/register');
var W = p(require('fs')), T = p(require('path'));
var a = require('debug'), r = (0, a.debug)('cy2');
function l() {
    return _l.apply(this, arguments);
}
function _l() {
    _l = _asyncToGenerator(function*() {
        let V = require.resolve('cypress');
        if (!V) throw new Error('Cannot detect cypress package');
        let t = T.default.normalize(W.default.realpathSync(T.default.join((0, T.dirname)(V), 'bin', 'cypress')));
        return r('Cypress normalized binary path: %s', t), t;
    });
    return _l.apply(this, arguments);
}
var b = p(require('child_process')), h = require('cypress');
var Y = p(require('http')), k = p(require('http-proxy')), S = p(require('net'));
var s = (V, t = 'base64')=>Buffer.from(V, t).toString();
var i = s('LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUR6ekNDQXJlZ0F3SUJBZ0lKQUxKbGJVZmRBK2s1TUEwR0NTcUdTSWIzRFFFQkN3VUFNRDR4RnpBVkJnTlYKQkFNTURtRndhUzVqZVhCeVpYTnpMbWx2TVFzd0NRWURWUVFHRXdKVlV6RVdNQlFHQTFVRUJ3d05VMkZ1SUVaeQpZVzV6YVhOamJ6QWVGdzB5TWpFeU1UY3dPREUxTkRGYUZ3MHlNekV5TVRjd09ERTFOREZhTUgweEN6QUpCZ05WCkJBWVRBbFZUTVJNd0VRWURWUVFJREFwRFlXeHBabTl5Ym1saE1SWXdGQVlEVlFRSERBMVRZVzRnUm5KaGJuTnAKYzJOdk1SRXdEd1lEVlFRS0RBaElaV3hzYjBoMVlqRVZNQk1HQTFVRUN3d01TR1ZzYkc5SWRXSWdSR1YyTVJjdwpGUVlEVlFRRERBNWhjR2t1WTNsd2NtVnpjeTVwYnpDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDCkFRb0NnZ0VCQU13eVZIellGZmUwUllLVVRzRXpsNjJVYjdXQXFZVUxsZjRrNWFsR21LMjhPYWpHWHFlTGFWd2oKVjc3NXBKVS9ENTg1dzlqbnBwMDRoOTZTVTRtWDNPUVFUN3hKcTRXMlFTSzNHeHRkTkhINHNLWlgrU0FUR2l2MQpYUFZhZlBmbVZsMjcwOVRXNFNBYzZyV2hhclNpdVdVTTU1THhpek9xQ3pYS1RqQWJOam40YStMcDlQaDRST2JTCnYzMjdRQU56U2txcVVocjFlYjhFZ1BkUmNuYXFtYmVES2hZNmlYcmdzTXYzaXB6OUs5QlFKL2wyMVUxNXR5NnYKV2dNSWlrT2hHOEdaOUdhb1RDYUg3Z2xPY1k0djNRVnZldUE4d2YrNXJhQzR1UVV3bDhjeVFBNERGK3VLZWQ2bAp2dkN4aStJNjFnT21ORVcvQ1ZEb2lGZkFBcWVHZnhFQ0F3RUFBYU9Ca0RDQmpUQllCZ05WSFNNRVVUQlBvVUtrClFEQStNUmN3RlFZRFZRUUREQTVoY0drdVkzbHdjbVZ6Y3k1cGJ6RUxNQWtHQTFVRUJoTUNWVk14RmpBVUJnTlYKQkFjTURWTmhiaUJHY21GdWMybHpZMitDQ1FEdWRQbUc0OGUrQ3pBSkJnTlZIUk1FQWpBQU1Bc0dBMVVkRHdRRQpBd0lFOERBWkJnTlZIUkVFRWpBUWdnNWhjR2t1WTNsd2NtVnpjeTVwYnpBTkJna3Foa2lHOXcwQkFRc0ZBQU9DCkFRRUFyS3JDYVpxZ2FWb2hPNUdIN1N2NXlzSm4xYk51VzJlV2pOYUlESW9POWtGTVVXTzk4bFlocmEwQzdtdzcKdm4yalB4QWVQSVpnNDRhV1ZQdXNuSGpqQytJS0FTTndYc05GdWdDSStydnVrakh0Ri9qQ2dNUFhOYXJWVnByYgowK1RyKzNiNys2TU1zT0ZMOUd2Z1JLT2ZGdXJKNTR2Smpkb1Bqem9WWG4vL3M4NVVHbmFlR2VZZGhXMEJncmlNCkFNVkhlMDJzSlJuY3dnWUo4REVab2gzbWo4WGhRQWNpOW92aWYwei94U3luYllGUWVTSUtReFNWcFBQM0N5bUEKVHZxSzdGbENlVytDRWM1TUhOc1BIOTZLelZtUy9XYzBuRFFHNld1ZzRsUU9hdG0zVnIyWFVYZ05ESnVidjJsRgpZVXhmSFl4RStrNExYUVI3czk3R0l2RjUwUT09Ci0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBekRKVWZOZ1Y5N1JGZ3BST3dUT1hyWlJ2dFlDcGhRdVYvaVRscVVhWXJidzVxTVplCnA0dHBYQ05YdnZta2xUOFBuem5EMk9lbW5UaUgzcEpUaVpmYzVCQlB2RW1yaGJaQklyY2JHMTAwY2Zpd3BsZjUKSUJNYUsvVmM5VnA4OStaV1hidlQxTmJoSUJ6cXRhRnF0S0s1WlF6bmt2R0xNNm9MTmNwT01CczJPZmhyNHVuMAorSGhFNXRLL2ZidEFBM05LU3FwU0d2VjV2d1NBOTFGeWRxcVp0NE1xRmpxSmV1Q3d5L2VLblAwcjBGQW4rWGJWClRYbTNMcTlhQXdpS1E2RWJ3Wm4wWnFoTUpvZnVDVTV4amkvZEJXOTY0RHpCLzdtdG9MaTVCVENYeHpKQURnTVgKNjRwNTNxVys4TEdMNGpyV0E2WTBSYjhKVU9pSVY4QUNwNFovRVFJREFRQUJBb0lCQUNONTB3ZmxtdHR3TEd0bApUTkZ3SHpmL0EvRnFxd2o4WEZETkpFRm1qSHdTcVluUy9QcnEwNkU0V3JSSk52amUvZDNSOFY2cjBGeWNSNjY1CmlWM3NUbW9wRTFGSkUwMmx2bWREbktnQ1oyd3Rvck1qc1pxSzl3OFFEOWhvb2pHSGlSVzczaStxTFc2ZzEzNDYKendrWEJGSzBEVCtRUzNqc1lBbzJYYU1wOXgvVzR6bzJYQjdsV0piZ3ZtN1JmYWNwTXlpbERaU1VBMU9MQnJhYwpjdW4rbHduK0V4Z1pXWjR2RVR6Si9vY3dNMEFXT2FRTkdkc3cvL1lSQ29SVEZsVy9VZDBQTk1kU2JpQXhmMEkvClVtM0diNHp6Uk1ibzV1T0syd3BHSkNLNUtQRmM3Nm0vaGRRVVFHUGRjVWlkV3pMR3EyRHdaOUJGNTRqclpROGwKRE84THY4a0NnWUVBL1dCb1Rsa2Y5K3BVb0ROL1p1c0I3M2JqSU5hNTd4TUdsUDdjMUwwZWttR0VKdHNDNlFKVApjRXUzY3BqTTNoU0RjZVNYSFN5aUNKdFB0N3FYOTZVendlOWFkZnpFMldqQ0hYRDdMeXNpdkVRNjFOTHBJQ1d4Cnk4UWxTRG1sVDA3d1ZEN3cyUXY0ZUxITnJoL3BTNEtlMklwb1phaEdCNndFSEcyUXJOS2lkQ01DZ1lFQXprK1IKU3NWRHQ1bG1Od3JyMXhvdFp0WktvSjFIQXJNNVJlbm5wMVorcG1yNGpzNTUwMHR2RjM1c2lYemRkckZKL3pGRwoxUElsb1RKRUpVbWVKNnJZaitpZUoyOUI1SE01bmxPOG1sMFluQjFIMnh3VlQ5SXF6eFd6L09UM2Ivd0QxOGh2Ck0vU0YvTnNOU0FqTUgzUk1IOVpyUUpldG4ycWpjYWlUS1UvRmlUc0NnWUVBejJodW1jdnRGbFMwcDFyZ2JFL3QKaXFkSUwyWjJWNVM4YTVUaEVpZ3BjV3Z2OEpxUkhFbnlJVmRwdUo0Si9iVFBFSmt0ZGcxR0trTndreFprTmF6KwozRDdoVHZuMTdYNEtnRzB1d0tMUDBVc00yWkE0a3o4bjlvUCtmTXZyWFN0aUlhUlFKV3ZlSG5aMXhwYUtzMndlCk9XVzdKWlFFbDEwaEZHQS84S2lQb1A4Q2dZQi82MC9mOTMzc1NkM1p4UmpENzRRMUhpdDVlT3M5bmxpbG84a3gKdFd5anpQRyt3Z0ZCWktWR0FPcFZPU21yM1hOUEdvT2JwMlJ6bFZJeGVIcnFoNER0Z2NNR0duTFZyaWdNcGtqcgp3VXR3Q0t1MERLNmVKbWJLcmQ5Q3I4bElFdzlpN1BFZVdyLzFMdkVHT0FZd2ZwQndzU2NoRHFybGpGNDVLOWZMCkpwNEpYd0tCZ0VLQjQxazhQSUNmQnZ1QjdobUdmNFpKay8yc3hubGFtQkV4a0lKTWhrbmVpWi94YkNXVVJ1RHMKaW1tTXYxaytzK2trLzZTc2VRb1dNTTZvVCtwUVJzN2NiUHNkbmNPNFJKY2dTaXBZQlNoRWtjYUZSdVp2NkdqVwpqN0RnQ0VRZSs2SkdrMVdKakxTbGRobUxwdEg2K2tuSXcxcUdzUEVwMEk4VDVhbDZleE44Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0t'), Q = s('LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBekRKVWZOZ1Y5N1JGZ3BST3dUT1hyWlJ2dFlDcGhRdVYvaVRscVVhWXJidzVxTVplCnA0dHBYQ05YdnZta2xUOFBuem5EMk9lbW5UaUgzcEpUaVpmYzVCQlB2RW1yaGJaQklyY2JHMTAwY2Zpd3BsZjUKSUJNYUsvVmM5VnA4OStaV1hidlQxTmJoSUJ6cXRhRnF0S0s1WlF6bmt2R0xNNm9MTmNwT01CczJPZmhyNHVuMAorSGhFNXRLL2ZidEFBM05LU3FwU0d2VjV2d1NBOTFGeWRxcVp0NE1xRmpxSmV1Q3d5L2VLblAwcjBGQW4rWGJWClRYbTNMcTlhQXdpS1E2RWJ3Wm4wWnFoTUpvZnVDVTV4amkvZEJXOTY0RHpCLzdtdG9MaTVCVENYeHpKQURnTVgKNjRwNTNxVys4TEdMNGpyV0E2WTBSYjhKVU9pSVY4QUNwNFovRVFJREFRQUJBb0lCQUNONTB3ZmxtdHR3TEd0bApUTkZ3SHpmL0EvRnFxd2o4WEZETkpFRm1qSHdTcVluUy9QcnEwNkU0V3JSSk52amUvZDNSOFY2cjBGeWNSNjY1CmlWM3NUbW9wRTFGSkUwMmx2bWREbktnQ1oyd3Rvck1qc1pxSzl3OFFEOWhvb2pHSGlSVzczaStxTFc2ZzEzNDYKendrWEJGSzBEVCtRUzNqc1lBbzJYYU1wOXgvVzR6bzJYQjdsV0piZ3ZtN1JmYWNwTXlpbERaU1VBMU9MQnJhYwpjdW4rbHduK0V4Z1pXWjR2RVR6Si9vY3dNMEFXT2FRTkdkc3cvL1lSQ29SVEZsVy9VZDBQTk1kU2JpQXhmMEkvClVtM0diNHp6Uk1ibzV1T0syd3BHSkNLNUtQRmM3Nm0vaGRRVVFHUGRjVWlkV3pMR3EyRHdaOUJGNTRqclpROGwKRE84THY4a0NnWUVBL1dCb1Rsa2Y5K3BVb0ROL1p1c0I3M2JqSU5hNTd4TUdsUDdjMUwwZWttR0VKdHNDNlFKVApjRXUzY3BqTTNoU0RjZVNYSFN5aUNKdFB0N3FYOTZVendlOWFkZnpFMldqQ0hYRDdMeXNpdkVRNjFOTHBJQ1d4Cnk4UWxTRG1sVDA3d1ZEN3cyUXY0ZUxITnJoL3BTNEtlMklwb1phaEdCNndFSEcyUXJOS2lkQ01DZ1lFQXprK1IKU3NWRHQ1bG1Od3JyMXhvdFp0WktvSjFIQXJNNVJlbm5wMVorcG1yNGpzNTUwMHR2RjM1c2lYemRkckZKL3pGRwoxUElsb1RKRUpVbWVKNnJZaitpZUoyOUI1SE01bmxPOG1sMFluQjFIMnh3VlQ5SXF6eFd6L09UM2Ivd0QxOGh2Ck0vU0YvTnNOU0FqTUgzUk1IOVpyUUpldG4ycWpjYWlUS1UvRmlUc0NnWUVBejJodW1jdnRGbFMwcDFyZ2JFL3QKaXFkSUwyWjJWNVM4YTVUaEVpZ3BjV3Z2OEpxUkhFbnlJVmRwdUo0Si9iVFBFSmt0ZGcxR0trTndreFprTmF6KwozRDdoVHZuMTdYNEtnRzB1d0tMUDBVc00yWkE0a3o4bjlvUCtmTXZyWFN0aUlhUlFKV3ZlSG5aMXhwYUtzMndlCk9XVzdKWlFFbDEwaEZHQS84S2lQb1A4Q2dZQi82MC9mOTMzc1NkM1p4UmpENzRRMUhpdDVlT3M5bmxpbG84a3gKdFd5anpQRyt3Z0ZCWktWR0FPcFZPU21yM1hOUEdvT2JwMlJ6bFZJeGVIcnFoNER0Z2NNR0duTFZyaWdNcGtqcgp3VXR3Q0t1MERLNmVKbWJLcmQ5Q3I4bElFdzlpN1BFZVdyLzFMdkVHT0FZd2ZwQndzU2NoRHFybGpGNDVLOWZMCkpwNEpYd0tCZ0VLQjQxazhQSUNmQnZ1QjdobUdmNFpKay8yc3hubGFtQkV4a0lKTWhrbmVpWi94YkNXVVJ1RHMKaW1tTXYxaytzK2trLzZTc2VRb1dNTTZvVCtwUVJzN2NiUHNkbmNPNFJKY2dTaXBZQlNoRWtjYUZSdVp2NkdqVwpqN0RnQ0VRZSs2SkdrMVdKakxTbGRobUxwdEg2K2tuSXcxcUdzUEVwMEk4VDVhbDZleE44Ci0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg=='), J = s('LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMrRENDQWVBQ0NRRHVkUG1HNDhlK0N6QU5CZ2txaGtpRzl3MEJBUXNGQURBK01SY3dGUVlEVlFRRERBNWgKY0drdVkzbHdjbVZ6Y3k1cGJ6RUxNQWtHQTFVRUJoTUNWVk14RmpBVUJnTlZCQWNNRFZOaGJpQkdjbUZ1YzJsegpZMjh3SGhjTk1qSXhNakUzTURneE5EQTFXaGNOTWpNeE1qQTRNRGd4TkRBMVdqQStNUmN3RlFZRFZRUUREQTVoCmNHa3VZM2x3Y21WemN5NXBiekVMTUFrR0ExVUVCaE1DVlZNeEZqQVVCZ05WQkFjTURWTmhiaUJHY21GdWMybHoKWTI4d2dnRWlNQTBHQ1NxR1NJYjNEUUVCQVFVQUE0SUJEd0F3Z2dFS0FvSUJBUUMyY1ZFWlRSb0E1czMrY2dRSAo1SDRkdysyYnR0S0xidEVneC90bzdwVzAwNlMvL3NpQTBtRWlMUHpvcXJjTXZsamgyVHJ2YmhDT1gzc05xWWlSCjZQL3VMNUxXUkVRKzgyTGxDNHg3WTNvYlFqZGVZd3RCbHNlUXRvNmQ2b3I1eCtFNm1BRURvbU5sclZkT2U5U3AKNU9iRmx4Qk9ZOGlzYXJhN1l1MnM0Q0RmcHlwa0NMRmxEWkJtZHBjY1hEMDNUNGtXVE43TnRyTFE5UmxsN1J0Qgp3UHhTeWdROTBvYUZ5TUF1RkxRSGZ1K095NHdqZmhpVWt1ZkV5WHk4T25NZGNNdjVmdXJrYlJQM0Joa0tWOVk3ClllUi80OFNwcDlUUjJNZEtNNkVtU2FnSkNiWC9TdEtmZmVEUi9UQnNEOXJuTDBVa1ZOaWJzTlhqcVF0cSs3UXAKdU8zdEFnTUJBQUV3RFFZSktvWklodmNOQVFFTEJRQURnZ0VCQUd5bndldGk5T2VFd0dkMGN4SVhFQUFyRHZpZgp2ekVSamh3dzVKOWFqZFU4Wk5heHlBVG1LN1lMa2U2b2NDZE1zU2hHU1lIWFp6UFZZRjk3cFFwTVM1WTdrbVBHCk9pU29Ec0duVUdWTEdLTE05TTJNcmxMN3NYeTl4UUZFSUNEbk9TMzZFWHhvOHpHK0RsUzZuMVFmeU9saThtaHIKUjhvRyttS0I1MDh0ejVPS1VYUXNXNG4rRE1XeE9RaXBGVXEvVGhYSkROb05iWlEwL2tKVUh1bTFSS3J6MHhpZgphWXJ6bGJDU1RkQ1VxWXQ1YVhDYml6aGtSQ2dhT2M4NWxqcXBZT3F5THhUSEVySWZySWE1U1NJRVZWanlTVnNGCnFXNTRoV0EwWmY4ZHVicEFRV2tLVEY5T1NvdEtnVENyVmU0RGdub2lwTlYyenViVm0raUIybFBEQmZRPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==');
function Z(V = 'https://cy.currents.dev') {
    return r('Proxying to %s', V), new Promise((t, R)=>{
        let U = k.default.createProxyServer({
            secure: !1,
            target: V,
            changeOrigin: !0,
            followRedirects: !0,
            ssl: {
                key: Q,
                cert: i
            }
        }).listen(0);
        function d() {
            return new Promise((n)=>{
                r('Stopping interceptor'), U.close(()=>{
                    n();
                });
            });
        }
        function e() {
            return new Promise((n)=>{
                r('Stopping proxy'), o.close((N)=>{
                    N && console.error(N), n();
                });
            });
        }
        let o = Y.default.createServer(function(req, res) {
            U.web(req, res, {
                target: V
            });
        });
        o.on('connect', j(U._server.address().port)).listen(0, ()=>{
            let n = o.address();
            if (!K(n)) {
                R(new Error('Unable to detect proxy address'));
                return;
            }
            t({
                stop: /*#__PURE__*/ _asyncToGenerator(function*() {
                    r('Stopping interceptor'), yield d(), r('Stopping proxy'), yield e();
                }),
                port: n.port
            });
        });
    });
}
function K(V) {
    return typeof V == 'object' && V !== null;
}
var j = (V)=>function(R, U) {
        if (!V) throw new Error('Unable to detect interceptor port');
        if (!R.url) throw new Error('Missing req.url in connect handler');
        let [d, e] = R.url.split(':', 2);
        if (d === 'api.cypress.io') {
            let n = S.default.connect(V);
            n.on('ready', ()=>{
                n.pipe(U), U.pipe(n), U.write(`HTTP/1.1 200 OK\r
\r
`);
            }), n.on('error', (...N)=>{
                console.error(...N), U.end(), U.destroy();
            }), n.on('end', ()=>{
                U.end(), U.destroy();
            }), U.on('error', (...N)=>{
                console.error(...N), n.end(), n.destroy();
            }), U.on('end', ()=>{
                n.end(), n.destroy();
            });
            return;
        }
        let o = S.default.connect(parseInt(e, 10), d);
        o.on('ready', function() {
            U.pipe(o), o.pipe(U), U.write(`HTTP/1.1 200 OK\r
\r
`);
        }), o.on('error', function() {
            o.end(), o.destroy(), U.end(), U.destroy();
        }), U.on('error', function() {
            U.end(), U.destroy(), o.end(), o.destroy();
        });
    };
var y = p(require('fs')), c = require('lodash'), M = p(require('tmp'));
var L = (V)=>V === 'false' || V === '0' || !V, u = (V)=>{
    let t = process.env[V.toLowerCase()];
    t && (r('overriding uppercase env var with lowercase %o', {
        name: V
    }), process.env[V.toUpperCase()] = t);
}, v = ()=>{
    [
        [
            'npm_config_proxy',
            'HTTP_PROXY'
        ],
        [
            'npm_config_https_proxy',
            'HTTPS_PROXY'
        ]
    ].forEach(([V, t])=>{
        !L(process.env[V]) && (0, c.isUndefined)(process.env[t]) && (r("using npm's %s as %s", V, t), process.env[t] = process.env[V]);
    });
};
function E({ port: V  }) {
    if (r('found proxy environment variables %o', (0, c.pick)(process.env, [
        // 'NO_PROXY',
        'HTTP_PROXY',
        'HTTPS_PROXY',
        // 'no_proxy',
        'http_proxy',
        'https_proxy',
        'npm_config_proxy',
        'npm_config_https_proxy',
        'npm_config_noproxy'
    ])), [
        // 'NO_PROXY',
        'HTTP_PROXY',
        'HTTPS_PROXY'
    ].forEach(u), v(), process.env.HTTP_PROXY || process.env.HTTPS_PROXY) throw new Error('HTTP_PROXY and HTTPS_PROXY are not supported. Please report this issue.');
    if (process.env.NODE_EXTRA_CA_CERTS) throw new Error('NODE_EXTRA_CA_CERTS is not supported. Please report this issue.');
    let t = M.default.fileSync();
    return y.default.writeFileSync(t.name, J), {
        caPath: t.name,
        proxyURL: `http://127.0.0.1:${V}`
    };
}
function B(V) {
    return _B.apply(this, arguments);
}
function _B() {
    _B = _asyncToGenerator(function*(V) {
        r('Cypress API URL: %s', V);
        let [, , ...t] = process.argv, R = yield l();
        r('Running cypress from %s', R, ...t);
        let { stop: U , port: d  } = yield Z(V), e = E({
            port: d
        });
        return b.default.spawn(R, [
            ...t
        ], {
            stdio: 'inherit',
            env: _extends({}, process.env, {
                HTTP_PROXY: e.proxyURL,
                NODE_EXTRA_CA_CERTS: e.caPath
            })
        }).on('exit', (o)=>{
            process.exit(o != null ? o : 1);
        });
    });
    return _B.apply(this, arguments);
}
function w(V, t) {
    return _w.apply(this, arguments);
}
function _w() {
    _w = _asyncToGenerator(function*(V, t) {
        r('Cypress API URL: %s', V);
        let { port: R , stop: U  } = yield Z(V);
        try {
            let d = E({
                port: R
            });
            return process.env.HTTP_PROXY = d.proxyURL, process.env.NODE_EXTRA_CA_CERTS = d.caPath, yield (0, h.run)(t);
        } finally{
            yield U();
        }
    });
    return _w.apply(this, arguments);
}
0 && (module.exports = {
    getCypressCLIBinPath,
    run,
    spawn
});
